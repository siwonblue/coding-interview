이진 탐색을 이용한 최대 증가 부분수열(Longest Increasing Subsequence, LIS) 풀이 방식이 처음에는 다소 혼란스러울 수 있습니다. 이 방법의 핵심은 실제 부분수열을 찾는 것이 아니라, 가능한 최대 길이의 부분수열을 추적하는 것입니다. 이 과정에서 이진 탐색은 최적의 위치에 새로운 요소를 빠르게 삽입할 수 있도록 도와줍니다.

### 이진 탐색 LIS 풀이 방법의 개요

1. **LIS 배열 생성 및 초기화**: 새로운 배열 `lis`를 만들어, 주어진 배열의 가능한 최대 증가 부분수열의 길이를 추적합니다. 초기에 이 배열은 비어 있습니다.

2. **주어진 배열 순회**:

   - 주어진 배열의 각 요소에 대해, `lis` 배열에서 해당 요소가 들어갈 수 있는 "적절한 위치"를 이진 탐색으로 찾습니다.
   - 이 위치는 `lis` 배열에서 현재 요소보다 크거나 같은 첫 번째 요소의 위치입니다.

3. **요소 삽입 또는 업데이트**:

   - 이진 탐색 결과, 현재 요소가 `lis` 배열의 모든 요소보다 큰 경우, 이 요소를 `lis` 배열 끝에 추가합니다.
   - 만약 `lis` 배열에 현재 요소보다 크거나 같은 요소가 이미 있다면, 그 위치를 현재 요소로 업데이트합니다.

4. **결과 반환**: 반복이 끝나면, `lis` 배열의 길이가 주어진 배열의 최대 증가 부분수열의 길이가 됩니다.

### 이해를 돕기 위한 예시

주어진 배열: `[10, 22, 9, 33, 21, 50, 41, 60, 80]`

이진 탐색을 사용하는 과정은 다음과 같습니다:

1. `10` 추가: `lis = [10]`
2. `22` 추가: `lis = [10, 22]`
3. `9`는 `10`보다 작으므로 `10`을 `9`로 업데이트: `lis = [9, 22]`
4. `33` 추가: `lis = [9, 22, 33]`
5. `21`는 `22`보다 작으므로 `22`를 `21`로 업데이트: `lis = [9, 21, 33]`
6. `50` 추가: `lis = [9, 21, 33, 50]`
7. `41`는 `50`보다 작으므로 `50`을 `41`로 업데이트: `lis = [9, 21, 33, 41]`
8. `60` 추가: `lis = [9, 21, 33, 41, 60]`
9. `80` 추가: `lis = [9, 21, 33, 41, 60, 80]`

결과적으로, `lis`의 길이는 6이며, 이는 주어진 배열에서 가능한 최대 증가 부분수열의 길이입니다. 주목해야 할 점은 `lis` 배열이 실제 최대 증가 부분수열을 나타내지는 않는다는 것입니다. 하지만, 이 배열의 길이는 최대 증가 부분수열의 길이와 일치합니다.

이 방법은 이진 탐색을 사용하여 각 요소를 삽입할 위치를 빠르게 찾기 때문에 효율적입니다. 전통적인 동적 프로그래밍 방식보다 더 빠른 \(O(N \log N)\) 시간 복잡도를 가집니다.
